---
title: "vectores_factores_matrices"
author: "Marco R."
date: "16-10-2020"
output:
  pdf_document:
    toc: yes
  html_document:
    fig_caption: yes
    highlight: haddock
    number_sections: yes
    theme: spacelab
    toc: yes
---



# Vectores
## VAmos a jugar al casino

```{r}
# Creamos un vector de los días de la semana
dias_semana = c("Lunes", "Martes", "Miercoles",
                "Jueves", "Viernes", 
                "Sabado", "Domingo")
vector_poker = c(140, -50, -20, 20, 100, 200, -100)
vector_ruleta = c(100, 100, -400, 20, 10, 100, 200)

# alternativa con scan()
#vector_ruleta <- scan() # con la función scan podemos introducir manualmente los valores en consola
vector_ruleta
```


```{r}
vector_poker
```



```{r}
# Asignacion de los nombres de las columnas
names(vector_poker) = dias_semana
names(vector_ruleta) = dias_semana
```


```{r}
vector_poker
```


```{r}
# Calculando las ganancias / pérdidas diarias
total_diario = vector_poker + vector_ruleta
total_diario
```

## Funciones básicas sobre los vectores

```{r}
length(vector_poker) # calcula la longitud del vector
max(vector_poker) # calcula el valor máximo
min(vector_poker) # calcula el valor mínimo

# which()
vector_ruleta[which(vector_ruleta>50)] # me devuelve unos resultados según la condición indicada que sea TRUE

# which.max y which.min devuelve los índices respectivos de los vectores
which.min(vector_poker)
which.max(vector_ruleta)

# Ordenar los vectores
sort(vector_poker) # ordena de menor a mayor los valores
sort(vector_poker, decreasing = TRUE) # ordena de mayor a menor los valores del vector
print(vector_poker)


# Operaciones
mean(vector_poker) # devuelve el promedio
median(vector_ruleta) # devuelve la mediana
var(vector_ruleta) # devuelve la varianza
cov(vector_poker, vector_ruleta) # covarianza
cor(vector_poker, vector_ruleta) # correlación
sd(vector_ruleta) # devueleve la desviación estandar

# valores absolutos y valores relativos
table(vector_poker) # dsitribución de las frecuencias absolutas
table(vector_ruleta) / length(vector_ruleta) # distribución de las frecuencias relativas
# table(vector_ruleta) / 7 ----->>>>> NUNCA NUNCA NUNCA


   
```


## Ciclo FOR aplicado a los vectores

```{r}
suma <- 0
for (i in vector_poker){
  suma <- suma+1 # suma los índices
}
suma
```


```{r}
suma <- 0
for (i in vector_poker){
  suma <- suma+i # suma los valores
}
suma
```


```{r}
# popular un vector
num <-  NULL # se inicializa con un vector VACIO
for (i in 1:100) {
  num <- c(num, i)
}

num
```




```{r}
# alternativa del método de asignación de arriba

num <- 0
for (i in 1:100) {
  num[i] <- i
}

num
```



```{r}
# otra forma de declarar los vectores
vector_1 <- scan()
vector_1
```

```{r}
# help(seq) ejecuta la ayuda de seq
seq(1,100) # genera secuencia de 100 num
```

```{r}
seq(1,100, by = 5) # devuelve una secuencia de valores de 1 a 100 con paso 5
seq()
seq(0, 1, length.out = 20)
seq(1,10, along.with = 1)
seq(stats::rnorm(20))
seq(1,100, by = pi)
pi
```



# Matrices en R

```{r}
# matrix() nrow - ncol por filas
A <-  matrix(c(1,4,6,8,-1,-4,0,6,0), 
             nrow = 3,
             ncol = 3,
             byrow = F # por defecto es FALSE
)
A
```

```{r}
# matrix() nrow - ncol por columnas
A <-  matrix(c(1,4,6,8,-1,-4,0,6,0), 
             nrow = 3,
             ncol = 3,
             byrow = T # forzamos el parámetro en TRUE
)
A
```


```{r}
# añadimos filas y columnas con las funciones rbind() y cbind()

matriz_2 <- cbind(A, c(-3,-5,9))
matriz_2

matrix_3 <- rbind(A, c(5,10,0))
matrix_3

# Probamos en añadir una fila con dos valores solamente ?¿ 
matrix_2 <- rbind(A, c(12, NULL, 10))
matrix_2
```


```{r}
matrix_2
```





```{r}
# Referenciamos los valores en la matriz
matrix_2[1,3] # extrae el valor de la primera fila, tercera columna

matrix_3[3,] # extrae los valores de la tercera fila

matrix_3[,2] # extrae los valores de la segunda columna

matrix_3[1:2, ] # extrae los valores de 2 filas y todas las columnas

matrix_3[2,2:3] # extrae los valores de la segunda fila, columna 2 y 3
```



### Operaciones con matrices

```{r}
dim(matrix_2) # dimensión de la matriz

dim(matrix_2)[1] # devuelve el resultado del números de filas de dim()

dim(matrix_2)[2] # devuelve el resultado del número de columnas de dim()
```

```{r}
diag(matrix_3) # extrae los elementos de la diagonal de la matriz

t(matrix_3)  # transpone una matriz

matrix_2*matrix_3 # operaciones de matrices

#matrix_2%*% matrix_2 producto escalado
```

## Declaramos las funciones

```{r}
cuadrado <- function(x){
  x^2
}

cuadrado(vector_ruleta)

```


```{r}
# Alternativa para aplicar una función personalizada
sapply(vector_ruleta, FUN = cuadrado)
```


### Factores

```{r}
student <- c(1, 3, 5, 7, 8, 9, 10)
fac <- factor(student, 
              levels = c(1,3,5,7,9,10),
              labels = c("Sup", "Sup", "Aprob", "Notab", "Exc","MH"))
fac
```


```{r}
genero <- c("Masculino", "Femenino", "Femenino", "Masculino", "Masculino")
factor_genero <- factor(genero)
factor_genero
```


```{r}
desempeno_laboral <- c("Alto", "Bajo", "Medio", "Alto", "Bajo", "Medio", "Alto", "Alto", "Bajo")
factor_laboral = factor(desempeno_laboral,
                        levels = c("Bajo", "Medio", "Alto"),
                        ordered = TRUE)
factor_laboral

```


```{r}

factor_laboral[1] # extrae el valor de la primera posición del vector
factor_laboral[2] # extrae el valor de la segunda pos del vector

factor_laboral[1] < factor_laboral[2] # devolverá FALSE porque ALTO es mayor que BAJO
factor_laboral[3] > factor_laboral[2] # devuelve TRUE porque MEDIO es mayor que BAJO
levels(factor_laboral) # devuelve los niveles del factor

is.ordered(factor_laboral) # está ordenado el factor (vector factorizado)
is.factor(desempeno_laboral) # es un factor el vector desempeno_laboral? Será FALSE porque es un vector simple



# Demostración del factor sin niveles sin ordenación
factor_2 <- as.factor(desempeno_laboral)
factor_2

factor_2[1]
factor_2[2]

#factor_2[1] > factor_2[2] # no puede realizar una comparativa porque no tenemos niveles ordenados

```


# Práctica con Matrices 







